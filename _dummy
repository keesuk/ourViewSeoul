  
drawSeoul() {

    const svgCanvas = d3.select(this.refs.canvas)
        .append("div")
        .classed("svg-container", true) 
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 1280 1280")
        .classed("svg-content-responsive", true)
    
    svgCanvas.selectAll("text")
        .data(dataArray)
        .enter()
            .append("text")
            .classed("text", true)
            .attr("x", d => { return d.xCor})
            .attr("y", d => { return height - d.yCor})
            .text(d => { return d.station})
            .attr("font-size", "6px")
} 

const addLineBreaks = string =>
  string.split('n').map((text, index) => (
    <React.Fragment key={`${text}-${index}`}>
      {text}
      <div/>
    </React.Fragment>
));

//---------------------------------------

import * as d3 from 'd3';

const voronoi = d3.voronoi();

const minRadius = 0.5,
  maxRadius = 3.5;

const radius = d3
  .scaleLinear()
  .range([maxRadius, minRadius])
  .clamp(true);

let iterations = 0;

const quadtree = d3.quadtree();

onmessage = function(event) {
  const { points, width, height, density, threshold } = event.data;

  voronoi.extent([[0, 0], [width, height]]);
  radius.domain([0, threshold]);
  compute();

  function compute() {
    if (iterations < 12) {
      voronoi(points)
        .polygons()
        .map(d3.polygonCentroid)
        .forEach(function(centroid, i) {
          points[i] = [
            ...centroid,
            density[width * Math.floor(centroid[1]) + Math.floor(centroid[0])]
          ];
          points[i].r = points[i][2] > threshold ? 0 : radius(points[i][2]);
        });
    } else if (!shrink(points)) {
      return;
    }
    iterations++;
    postMessage(points);
    setTimeout(compute, 0);
  }
};

function shrink(points) {
  if (!quadtree.size()) {
    quadtree.addAll(points);
  }

  points.forEach(function(point) {
    point.shrink = false;
    quadtree.visit(function(node, x0, y0, x1, y1) {
      if (
        point.shrink ||
        (!node.data &&
          (node.x0 > point[0] + point.r ||
            node.x1 < point[0] - point.r ||
            (node.y0 > point[1] + point.r || node.y1 < point[1] - point.r)))
      ) {
        return true;
      }
      if (node.data && node.data !== point) {
        const diff = collides(node.data, point);
        if (diff > 0) {
          [point, node.data].forEach(function(p) {
            p.shrink = true;
          });
        }
      }
    });
  });

  let collision = false;

  points.forEach(function(point) {
    if (point.shrink && point.r > minRadius) {
      point.r = Math.max(minRadius, point.r * 0.9);
      collision = true;
    }
  });

  return collision;
}

function collides(a, b) {
  const dx = a[0] - b[0],
    dy = a[1] - b[1],
    dr = a.r + b.r;

  return dr - Math.sqrt(dx * dx + dy * dy);
}
// ------------------------------------------
const width = 800;
const height = 500;
const threshold = 0.9;

function getDensityFunction(props) {
    const {context} = props
    const data = context.getImageData(0, 0, width, height).data;

    return d3.range(0, data.length, 4).map(i => data[i] / 255);
}

function generatePoints(props) {
    const {density, numPoints} = props
    return d3.range(numPoints).map(function() {
        let x, y, d;
    
        while (true) {
            x = Math.random() * width;
            y = Math.random() * height;
    
            d = density[width * Math.floor(y) + Math.floor(x)];
    
            if (Math.random() > d) {
                return [x, y, d];
            }
        }
    });
}

updateCanvas() {
  const canvas = d3.select(this.refs.canvas)
  const context = this.refs.canvas.getContext('2d');
  const img = new Image();

  context.fillStyle = "#000";

  img.onload = () => {
      context.drawImage(img, 0, 0, width, height);

      StackBlur.canvasRGB(canvas, 0, 0, width, height)
      const density = getDensityFunction({context});
    
    
      const points = generatePoints({density, numPoints : 5000});

      this.worker.postMessage({ density, points, width, height, threshold });
      this.worker.onmessage = (event) => this.draw(event.data);
  }
  img.src = this.props.src;

  this.draw = (props) => {
      const points = props
      context.clearRect(width, 0, width, height);
  
      points.forEach(function(point) {
          context.beginPath();
  
          if (point.r) {
              context.arc(width + point[0], point[1], point.r, 0, 2 * Math.PI);
              context.fill();
          }
      });
  }
  console.log(canvas);
}


                        <svg preserveAspectRatio="xMidYMid meet" viewBox="0 0 1280 1280" className="svg-content-responsive">
                            {data.map( (d, i) => 
                                <text
                                    className="station-text"
                                    onClick={() => this.windowOn()}
                                    key={i} 
                                    width={10}
                                    height={5}
                                    x={d.xCor}
                                    y={height - d.yCor}
                                > {d.station}
                                </text>
                            )}
                        </svg>


        csv(seoulPlace).then( (data) => {
            this.setState( {data} )
        })


        import React, { Component } from 'react';

class Portal extends Component {
    state = {  
        id : '',
    }

    onFormSubmit = () => {
        this.props.onSubmit(this.state.id)
    	console.log(this.state.id);
    }

    render() { 
        console.log(this.props.stationData);
        return null
    }
}
 
export default Portal;


//----------------- image.jsx

import React, { Component } from 'react';
import * as d3 from 'd3';
import data from '../data/seoul.json'
import Worker from 'worker-loader!./Worker'; // eslint-disable-line import/no-webpack-loader-syntax

const width = 600;
  
class Img extends Component {
    state = {
            width : null,
            height : null,
            data : [],
            clickValue : .6,
        }


    componentDidMount() {
        this.worker = new Worker();
        this.imageData();
    }

    imageData() {
        d3.image(this.props.src,  {crossOrigin: "anonymous"}).then(image => {
            const height = Math.round(width * image.height / image.width);
            const context = this.refs.canvas.getContext('2d');
            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
            console.log(context.getImageData(0, 0, width, height))
            const {data: rgba} = context.getImageData(0, 0, width, height);
            const data = new Float64Array(width * height);
            for (let i = 0, n = rgba.length / 4; i < n; ++i) {
                data[i] = Math.max(0, 1 - rgba[i * 4] / 200)
            };
            this.setState({ width, height, data })
            this.updateCanvas();
        })
    }

    updateCanvas() {
        const { width, height, data, clickValue } = this.state
        const context = this.refs.canvas.getContext('2d');
        const n = Math.round(width * height / 40)

        function messaged({ data: points}) {
            context.fillStyle = "#fff";
            context.fillRect(0, 0, width, height);
            context.beginPath();
            for (let i = 0, n = points.length; i < n; i += 2) {
                const x = points[i], y = points[i + 1];
                context.moveTo(x + 1.5, y);
                context.arc(x, y, 2+clickValue, 0, 2 * Math.PI);
            }
            context.fillStyle = "#000";
            context.fill();
        }

        this.worker.addEventListener("message", messaged);
        this.worker.postMessage({data, width, height, n});
    }
      
    render() {
        return (
            <canvas width={width} height={width} style={{width:'100%', height:'100%'}} ref="canvas" />
        );
    }
}

export default Img;


//------------mapping img



        // const { imgList } = stationDatas.map(stationData => { 
        //     return (
        //         <Img points = {stationData.locationData} className="img-stations"/>
        //     )}
        // )

        {/* {imgList} */}


        json.list.map(data => this.state.locationDatas.push(data))


//----------- worker


import {Delaunay} from "d3-delaunay";

onmessage = event => {
  const {data: {data, width, height, n}} = event;
  const points = new Float64Array(n * 2);
  const c = new Float64Array(n * 2);
  const s = new Float64Array(n);

  // Initialize the points using rejection sampling.
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < 30; ++j) {
      const x = points[i * 2] = Math.floor(Math.random() * width);
      const y = points[i * 2 + 1] = Math.floor(Math.random() * height);
      if (Math.random() < data[y * width + x]) break;
    }
  }

  const delaunay = new Delaunay(points);
  const voronoi = delaunay.voronoi([0, 0, width, height]);

  for (let k = 0; k < 80; ++k) {

    // Compute the weighted centroid for each Voronoi cell.
    c.fill(0);
    s.fill(0);
    for (let y = 0, i = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const w = data[y * width + x];
        i = delaunay.find(x + 0.5, y + 0.5, i);
        s[i] += w;
        c[i * 2] += w * (x + 0.5);
        c[i * 2 + 1] += w * (y + 0.5);
      }
    }

    // Relax the diagram by moving points to the weighted centroid.
    // Wiggle the points a little bit so they don’t get stuck.
    const w = Math.pow(k + 1, -0.8) * 10;
    for (let i = 0; i < n; ++i) {
      const x0 = points[i * 2], y0 = points[i * 2 + 1];
      const x1 = s[i] ? c[i * 2] / s[i] : x0, y1 = s[i] ? c[i * 2 + 1] / s[i] : y0;
      points[i * 2] = x0 + (x1 - x0) * 1.8 + (Math.random() - 0.5) * w;
      points[i * 2 + 1] = y0 + (y1 - y0) * 1.8 + (Math.random() - 0.5) * w;
    }

    postMessage(points);
    voronoi.update();
  }
  
  close();
};

//-------

json.list.map(data => this.state.locationDatas.push(data))



        if(this.props.station !== ':station'){
            fetch(API+ this.props.station )
                .then(response => response.json())
                .then(json => json.list.map(data => this.state.locationDatas.push(data)))
        }
    }

//----------

,
                // width: show ? '99vw' : '60vw',
                // boxShadow: show ? '10px -10px black' : '0px 0px 0px black'


//---------- scroll


::-webkit-scrollbar {
  float: left;
  margin-bottom: 25px;
  margin-left: 22px;
  margin-top: 40px;
  width: 10px;
  overflow-y: scroll;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: black;
}

::-webkit-scrollbar-thumb:hover {
  background: black;
}


//---------

// const { imgList } = stationDatas.map(stationData => { 
        //     return (
        //         <Img 
        //             key={stationData.location} 
        //             points={stationData.locationData} 
        //             className="img-stations"
        //         />
        //     )}
        // )


//---------ㅎㅔ더


                    <div className="computer">
                        <strong>{stationDatas[0] && stationDatas[0].station}</strong>
                    </div>


/* 
.computer {
    padding-bottom: 0px;
    font-size: 23px;
    font-weight: 600;
}
@media all and (min-width:0px) and (max-width:1023px) {
    .computer {
        font-size: 17px;
        padding-bottom: 2px;
    }
  } */


//---------------- 

function chooseShape(whatImgWillBe, items, id) {
    if(id === '0')whatImgWillBe.push(items[circle], randomize(circleItems), items[circle], randomize(circleItems)) 
    else if(id === '1')whatImgWillBe.push(items[rect], randomize(rectItems), items[rect], randomize(rectItems)) 
    else if(id === '2')whatImgWillBe.push(items[ellipse], randomize(ellipseItems), items[ellipse], randomize(ellipseItems)) 
    else if(id === '3')whatImgWillBe.push(items[triangle], randomize(triangleItems), items[triangle], randomize(triangleItems)) 
    else if(id === '4')whatImgWillBe.push(items[rhombus], randomize(rhombusItems), items[rhombus], randomize(rhombusItems)) 

    return whatImgWillBe
}

//----------


import React, { Component } from 'react';

const width  = 500;
const height = width;

const sendCountLimit = 6;

const colorItems    = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
const colorList     = ['#E20000','#006CC4','#EFC820','#087A0D','#7B2E8E']
const shapeItems    = ['●', '◼︎', '⬬', '▲', '♦︎']

const ItemsList = [
    ['🟥', '😁', '🟣', '🕚', '😎'],
    ['🩳', '🟥', '📺', '💾', '⏹'],
    ['🌀', '🏮', '💊', '🏈', '🪐'],
    ['💜', '🔺', '⛱', '💩', '🙏'],
    ['💋', '💎', '🪁', '🔷', '💠']
]

class Img extends Component {
    constructor() {
        super();
        this.state = { 
            count : 0,
            finalOn : false,
            ImgProp : [],
        };
        this.clickPoint = this.clickPoint.bind(this);
        this.sendCount = this.sendCount.bind(this);
        this.finalCanvas = this.finalCanvas.bind(this);
    }


    componentDidMount() {
        this.updateCanvas()
        this.chooseShape()
        this.clickPoint()
    }

    chooseShape() {
        const { locationId, locationName } = this.props
        this.setState(state => ({ImgProp : [...state.ImgProp, 
            locationId, //태그 번호
            colorList[locationId], //도형별 고유 컬러
            shapeItems[locationId], //도형
            randomize(ItemsList[locationId]), //랜덤화 
            randomize(ItemsList[locationId]), 
            randomize(ItemsList[locationId]) 
        ]}))
    }

    updateCanvas() {
        const points = this.props.points
        const { count, ImgProp } = this.state
        const context = this.refs.canvas.getContext('2d')
        
        context.fillStyle = 'white'
        context.fillRect(0, 0, width, height)

        for(let i = 0, n = points && points.length; i < n; i += 2){
            context.beginPath()
            const x = points[i]
            const y = points[i + 1]
            imgMaker(this.props.locationId, ImgProp, count, context, x, y)
        }
    }

    finalCanvas(){
        const ImgProp = this.state.ImgProp
        const context = this.refs.canvas.getContext('2d')
        context.fillStyle = 'white'
        context.fillRect(0, 0, width, height)

        context.font = '90px sans'
        context.fillStyle = ImgProp[1];
        context.fillText(shapeItems[this.props.locationId], 100, 300)
    }

    clickPoint() {
        this.setState(state => ({count : state.count + 1}))
        if(this.state.count === sendCountLimit){
            this.setState({finalOn : true})
            this.sendCount()
            this.finalCanvas()
        }else{
            this.updateCanvas()
        }
    }

    sendCount() {
        this.props.onOk(this.props.chilcOk)
    }

      
    render() {
        return (
            <>{this.state.finalOn 
            ?<canvas
                width={width} 
                height={height}
                style={{width:'100%', height:'100%'}} 
                ref="canvas" 
            />
            :<canvas 
                width={width} 
                height={height}
                onClick={this.clickPoint}
                style={{width:'100%', height:'100%', cursor:'pointer'}} 
                ref="canvas" 
            />}
            </>
        );
    }
}

export default Img;


function randomize(items) {
    const item = items[Math.floor(Math.random() * items.length)]
    return item
}

function imgMaker(id, ImgProp, count, context, x, y){

    function colorMaker(items) {
        const item = []
        for(let i = 0; i < 6; i++)item.push(randomize(items))
        return item[0]+item[1]+item[2]+item[3]+item[4]+item[5];
    }

    if(count === 0){
        context.font = '8.8px sans'
        context.fillStyle = "#000";
        context.fillText(shapeItems[id], x+1.5, y)
        context.fill();
    }else if(count === 1){
        context.font = '10px sans'
        context.fillText(ImgProp[3], x, y)
    }else if(count === 2){
        context.font = '8.8px sans'
        context.fillStyle = '#' + colorMaker(colorItems)
        context.fillText(ImgProp[2], x+1.5, y)
        context.fill();
    }else if(count === 3){
        context.font = '10px sans'
        context.fillText(ImgProp[4], x-1, y)
    }else if(count === 4){
        context.font = '11px sans'
        context.fillStyle = '#' + colorMaker(colorItems)
        context.fillText(ImgProp[2], x, y)
        context.fill();
    }else if(count === 5){
        context.font = '11px sans'
        context.fillStyle = ImgProp[1]
        context.fillText(ImgProp[2], x, y)
        context.fill();
    }
}


//--------------

{"0 0 "+ this.props.width + " " + this.props.height}

//----------

// function change(items) {
//     i = (i + 1) % items.length;
//     return items[i]
// }