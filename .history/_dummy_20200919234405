  
drawSeoul() {

    const svgCanvas = d3.select(this.refs.canvas)
        .append("div")
        .classed("svg-container", true) 
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 1280 1280")
        .classed("svg-content-responsive", true)
    
    svgCanvas.selectAll("text")
        .data(dataArray)
        .enter()
            .append("text")
            .classed("text", true)
            .attr("x", d => { return d.xCor})
            .attr("y", d => { return height - d.yCor})
            .text(d => { return d.station})
            .attr("font-size", "6px")
} 

const addLineBreaks = string =>
  string.split('n').map((text, index) => (
    <React.Fragment key={`${text}-${index}`}>
      {text}
      <div/>
    </React.Fragment>
));

//---------------------------------------

import * as d3 from 'd3';

const voronoi = d3.voronoi();

const minRadius = 0.5,
  maxRadius = 3.5;

const radius = d3
  .scaleLinear()
  .range([maxRadius, minRadius])
  .clamp(true);

let iterations = 0;

const quadtree = d3.quadtree();

onmessage = function(event) {
  const { points, width, height, density, threshold } = event.data;

  voronoi.extent([[0, 0], [width, height]]);
  radius.domain([0, threshold]);
  compute();

  function compute() {
    if (iterations < 12) {
      voronoi(points)
        .polygons()
        .map(d3.polygonCentroid)
        .forEach(function(centroid, i) {
          points[i] = [
            ...centroid,
            density[width * Math.floor(centroid[1]) + Math.floor(centroid[0])]
          ];
          points[i].r = points[i][2] > threshold ? 0 : radius(points[i][2]);
        });
    } else if (!shrink(points)) {
      return;
    }
    iterations++;
    postMessage(points);
    setTimeout(compute, 0);
  }
};

function shrink(points) {
  if (!quadtree.size()) {
    quadtree.addAll(points);
  }

  points.forEach(function(point) {
    point.shrink = false;
    quadtree.visit(function(node, x0, y0, x1, y1) {
      if (
        point.shrink ||
        (!node.data &&
          (node.x0 > point[0] + point.r ||
            node.x1 < point[0] - point.r ||
            (node.y0 > point[1] + point.r || node.y1 < point[1] - point.r)))
      ) {
        return true;
      }
      if (node.data && node.data !== point) {
        const diff = collides(node.data, point);
        if (diff > 0) {
          [point, node.data].forEach(function(p) {
            p.shrink = true;
          });
        }
      }
    });
  });

  let collision = false;

  points.forEach(function(point) {
    if (point.shrink && point.r > minRadius) {
      point.r = Math.max(minRadius, point.r * 0.9);
      collision = true;
    }
  });

  return collision;
}

function collides(a, b) {
  const dx = a[0] - b[0],
    dy = a[1] - b[1],
    dr = a.r + b.r;

  return dr - Math.sqrt(dx * dx + dy * dy);
}
// ------------------------------------------
const width = 800;
const height = 500;
const threshold = 0.9;

function getDensityFunction(props) {
    const {context} = props
    const data = context.getImageData(0, 0, width, height).data;

    return d3.range(0, data.length, 4).map(i => data[i] / 255);
}

function generatePoints(props) {
    const {density, numPoints} = props
    return d3.range(numPoints).map(function() {
        let x, y, d;
    
        while (true) {
            x = Math.random() * width;
            y = Math.random() * height;
    
            d = density[width * Math.floor(y) + Math.floor(x)];
    
            if (Math.random() > d) {
                return [x, y, d];
            }
        }
    });
}

updateCanvas() {
  const canvas = d3.select(this.refs.canvas)
  const context = this.refs.canvas.getContext('2d');
  const img = new Image();

  context.fillStyle = "#000";

  img.onload = () => {
      context.drawImage(img, 0, 0, width, height);

      StackBlur.canvasRGB(canvas, 0, 0, width, height)
      const density = getDensityFunction({context});
    
    
      const points = generatePoints({density, numPoints : 5000});

      this.worker.postMessage({ density, points, width, height, threshold });
      this.worker.onmessage = (event) => this.draw(event.data);
  }
  img.src = this.props.src;

  this.draw = (props) => {
      const points = props
      context.clearRect(width, 0, width, height);
  
      points.forEach(function(point) {
          context.beginPath();
  
          if (point.r) {
              context.arc(width + point[0], point[1], point.r, 0, 2 * Math.PI);
              context.fill();
          }
      });
  }
  console.log(canvas);
}


                        <svg preserveAspectRatio="xMidYMid meet" viewBox="0 0 1280 1280" className="svg-content-responsive">
                            {data.map( (d, i) => 
                                <text
                                    className="station-text"
                                    onClick={() => this.windowOn()}
                                    key={i} 
                                    width={10}
                                    height={5}
                                    x={d.xCor}
                                    y={height - d.yCor}
                                > {d.station}
                                </text>
                            )}
                        </svg>


        csv(seoulPlace).then( (data) => {
            this.setState( {data} )
        })


        import React, { Component } from 'react';

class Portal extends Component {
    state = {  
        id : '',
    }

    onFormSubmit = () => {
        this.props.onSubmit(this.state.id)
    	console.log(this.state.id);
    }

    render() { 
        console.log(this.props.stationData);
        return null
    }
}
 
export default Portal;


//----------------- image.jsx

import React, { Component } from 'react';
import * as d3 from 'd3';
import data from '../data/seoul.json'
import Worker from 'worker-loader!./Worker'; // eslint-disable-line import/no-webpack-loader-syntax

const width = 600;
  
class Img extends Component {
    state = {
            width : null,
            height : null,
            data : [],
            clickValue : .6,
        }


    componentDidMount() {
        this.worker = new Worker();
        this.imageData();
    }

    imageData() {
        d3.image(this.props.src,  {crossOrigin: "anonymous"}).then(image => {
            const height = Math.round(width * image.height / image.width);
            const context = this.refs.canvas.getContext('2d');
            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
            console.log(context.getImageData(0, 0, width, height))
            const {data: rgba} = context.getImageData(0, 0, width, height);
            const data = new Float64Array(width * height);
            for (let i = 0, n = rgba.length / 4; i < n; ++i) {
                data[i] = Math.max(0, 1 - rgba[i * 4] / 200)
            };
            this.setState({ width, height, data })
            this.updateCanvas();
        })
    }

    updateCanvas() {
        const { width, height, data, clickValue } = this.state
        const context = this.refs.canvas.getContext('2d');
        const n = Math.round(width * height / 40)

        function messaged({ data: points}) {
            context.fillStyle = "#fff";
            context.fillRect(0, 0, width, height);
            context.beginPath();
            for (let i = 0, n = points.length; i < n; i += 2) {
                const x = points[i], y = points[i + 1];
                context.moveTo(x + 1.5, y);
                context.arc(x, y, 2+clickValue, 0, 2 * Math.PI);
            }
            context.fillStyle = "#000";
            context.fill();
        }

        this.worker.addEventListener("message", messaged);
        this.worker.postMessage({data, width, height, n});
    }
      
    render() {
        return (
            <canvas width={width} height={width} style={{width:'100%', height:'100%'}} ref="canvas" />
        );
    }
}

export default Img;


//------------mapping img



        // const { imgList } = stationDatas.map(stationData => { 
        //     return (
        //         <Img points = {stationData.locationData} className="img-stations"/>
        //     )}
        // )

        {/* {imgList} */}


        json.list.map(data => this.state.locationDatas.push(data))


//----------- worker


import {Delaunay} from "d3-delaunay";

onmessage = event => {
  const {data: {data, width, height, n}} = event;
  const points = new Float64Array(n * 2);
  const c = new Float64Array(n * 2);
  const s = new Float64Array(n);

  // Initialize the points using rejection sampling.
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < 30; ++j) {
      const x = points[i * 2] = Math.floor(Math.random() * width);
      const y = points[i * 2 + 1] = Math.floor(Math.random() * height);
      if (Math.random() < data[y * width + x]) break;
    }
  }

  const delaunay = new Delaunay(points);
  const voronoi = delaunay.voronoi([0, 0, width, height]);

  for (let k = 0; k < 80; ++k) {

    // Compute the weighted centroid for each Voronoi cell.
    c.fill(0);
    s.fill(0);
    for (let y = 0, i = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const w = data[y * width + x];
        i = delaunay.find(x + 0.5, y + 0.5, i);
        s[i] += w;
        c[i * 2] += w * (x + 0.5);
        c[i * 2 + 1] += w * (y + 0.5);
      }
    }

    // Relax the diagram by moving points to the weighted centroid.
    // Wiggle the points a little bit so they donâ€™t get stuck.
    const w = Math.pow(k + 1, -0.8) * 10;
    for (let i = 0; i < n; ++i) {
      const x0 = points[i * 2], y0 = points[i * 2 + 1];
      const x1 = s[i] ? c[i * 2] / s[i] : x0, y1 = s[i] ? c[i * 2 + 1] / s[i] : y0;
      points[i * 2] = x0 + (x1 - x0) * 1.8 + (Math.random() - 0.5) * w;
      points[i * 2 + 1] = y0 + (y1 - y0) * 1.8 + (Math.random() - 0.5) * w;
    }

    postMessage(points);
    voronoi.update();
  }
  
  close();
};

//-------

json.list.map(data => this.state.locationDatas.push(data))



        if(this.props.station !== ':station'){
            fetch(API+ this.props.station )
                .then(response => response.json())
                .then(json => json.list.map(data => this.state.locationDatas.push(data)))
        }
    }

//----------

,
                // width: show ? '99vw' : '60vw',
                // boxShadow: show ? '10px -10px black' : '0px 0px 0px black'